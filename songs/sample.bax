## sample.bax
## BeatBax Sample song
## This file illustrates common language features and maps them to 4 Game Boy-like
## channels (Pulse1, Pulse2, Wave, Noise). Read each section below for details.

song name "Sample Song"
song artist "kadraman"
song description """BeatBax Sample song â€” illustrates common language features and maps them to 4 Game Boy-like channels (Pulse1, Pulse2, Wave, Noise)."""
song tags "example,imported,metadata"

chip gameboy
bpm 128

# -----------------------------------------------------------------------------
# Instruments
# Each `inst` defines a Game Boy-style instrument. Fields:
#  - `type`: one of `pulse1`, `pulse2`, `wave`, `noise`
#  - `duty`: duty cycle percentage for pulse channels (controls timbre)
#  - `env`: envelope. Use Game Boy-style envelope syntax `gb:<initial>,<up|down>,<period>`
#      e.g. `env=gb:12,down,1` sets initial vol=12 (0-15), direction down, period=1
#      For backwards compatibility legacy forms like `env=12,down` are accepted
#      but the `gb:` prefix or three-token form (`12,down,1`) is recommended.
#  - `wave`: an explicit 16-entry wavetable for `wave` type (4-bit values)
#
# The instruments below are chosen to show different channel roles:
# The instruments below are chosen to show different channel roles.
# You may optionally annotate instruments with a General MIDI program number
# using `gm=<0-127>`. The exporter will use this value for Program Change
# messages when exporting MIDI. Example: `inst leadA ... gm=81` (Lead 1).
inst leadA type=pulse1 duty=60 env=gb:12,down,1 gm=81   # Bright pulse lead, slightly wider duty (GM 81)
inst leadB type=pulse2 duty=30 env=gb:7,down,1 uge_transpose=+12 gm=34   # Bass with oct(-1) needs +24 (2 octaves) for UGE (GM 34)
inst wave1 type=wave  wave=[0,3,6,9,12,9,6,3,0,3,6,9,12,9,6,3] gm=82  # Wavetable arpeggio voice (GM 82)
inst snare type=noise  env=gb:12,down,1            # Snare-like noise for backbeat
inst hihat type=noise  env=gb:5,down,1             # Short hi-hat hits (faster, lower env)
inst perc  type=noise  env=gb:10,down,1            # Generic percussion/noise channel

# -----------------------------------------------------------------------------
# Patterns
# Patterns are sequences of tokens (notes like C4, rests `.` and identifiers).
# They may include grouping with `(...)` and repetition with `*N`.
# Inline tokens like `inst(name)` or `inst(name,N)` temporarily change the
# instrument for the following notes (temporary override count `N` decrements
# when non-rest notes are played).

# Melodic pattern for the lead channel.
# - Twinkle-style motif arranged into a fixed 16-token pattern (two 8-step phrases).
pat melody      = (C5 C5 G5 G5 A5 A5 G5 .) (F5 F5 E5 E5 D5 D5 C5 .)

# Alternative, sparser lead pattern for variation (16 tokens total).
pat melody_alt  = (C5 . C5 . G5 . G5 E5) * 2

# Simple bass pattern that follows the root movement of the melody (16 tokens).
pat bass_pat      = C3 C3 G2 G2 A2 A2 G2 . C3 C3 G2 G2 A2 A2 G2 .

# Wavetable arpeggio pattern to add harmonic color under the melody (16 tokens).
pat arp      = (C4 E4 G4 C5) (C4 E4 G4 C5) (C4 E4 G4 C5) (C4 E4 G4 C5)

# Reduced percussion pattern: fewer explicit hits spread over 16 tokens.
pat drums_pat      = (snare . . .) (snare . . .) (snare . . .) (snare . hihat .)

# Short melodic fill used between phrases (16 tokens).
pat fill      = (C5 E5 G5 C6) * 4

# -----------------------------------------------------------------------------
# New shorthand examples
# You can use `name*n` as a concise shorthand to emit the named instrument
# hit 4 times in a row (equivalent to `hit(name,4)`). This is useful for
# percussion stabs where you want immediate repeated hits without inserting
# explicit note tokens. `inst(name,N)` still acts as a temporary override
# for the next N non-rest notes.
pat drums_alt     = (snare . . .)*2 perc . . . . . . .

# -----------------------------------------------------------------------------
# Channel routing
# Map logical channels to instruments and patterns. Each `channel N => ...`
# line sets the channel ID (1-4) and a default instrument plus the sequence
# to play. `bpm=` controls tempo for that channel.
# - Channel 1: Pulse 1 lead (primary melody)
# - Channel 2: Pulse 2 lead (harmonic/alternate melody)
# - Channel 3: Wave channel (wavetable arpeggio) transposed down one octave
# - Channel 4: Noise/percussion channel

## Example sequencing: create separate sequences per part and map to channels
# Each channel consumes its own sequence. This keeps parts independent and
# lets you modify/loop them separately in the tracker or live UI.

# Lead sequence (primary melody)
seq lead = melody melody_alt fill melody

# Bass sequence (low-end walking bass)
seq bass = bass_pat bass_pat bass_pat bass_pat

# Wave sequence (wavetable arpeggios)
seq wave = arp arp arp

# Drums/percussion sequence
seq drums = drums_pat drums_alt drums_pat drums_alt

## Map channels to their separate sequences.
channel 1 => inst leadA seq lead lead
channel 2 => inst leadB seq bass bass
channel 3 => inst wave1 seq wave:oct(-1) wave
channel 4 => inst perc  seq drums drums

# -----------------------------------------------------------------------------
# Playback directive
# The `play` directive starts playback in the web UI player. In the CLI this
# would trigger immediate rendering or playback; in the web UI the UI uses the
# parsed AST to schedule audio.
play auto repeat
