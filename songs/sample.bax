## Sample song for the demo
## This file illustrates common language features and maps them to 4 Game Boy-like
## channels (Pulse1, Pulse2, Wave, Noise). Read each section below for details.

chip gameboy

bpm 120

# -----------------------------------------------------------------------------
# Instruments
# Each `inst` defines a Game Boy-style instrument. Fields:
#  - `type`: one of `pulse1`, `pulse2`, `wave`, `noise`
#  - `duty`: duty cycle percentage for pulse channels (controls timbre)
#  - `env`: envelope. Use Game Boy-style envelope syntax `gb:<initial>,<up|down>,<period>`
#      e.g. `env=gb:12,down,1` sets initial vol=12 (0-15), direction down, period=1
#      For backwards compatibility legacy forms like `env=12,down` are accepted
#      but the `gb:` prefix or three-token form (`12,down,1`) is recommended.
#  - `wave`: an explicit 16-entry wavetable for `wave` type (4-bit values)
#
# The instruments below are chosen to show different channel roles:
# The instruments below are chosen to show different channel roles.
# You may optionally annotate instruments with a General MIDI program number
# using `gm=<0-127>`. The exporter will use this value for Program Change
# messages when exporting MIDI. Example: `inst leadA ... gm=81` (Lead 1).
inst leadA type=pulse1 duty=60 env=gb:12,down,1 gm=81   # Bright pulse lead, slightly wider duty (GM 81)
inst leadB type=pulse2 duty=30 env=gb:7,down,1  gm=34   # Narrower pulse (used as temporary override) (GM 34)
inst wave1 type=wave  wave=[0,3,6,9,12,9,6,3,0,3,6,9,12,9,6,3] gm=82  # Wavetable arpeggio voice (GM 82)
inst sn    type=noise  env=gb:12,down,1            # Snare-like noise for backbeat
inst hihat type=noise  env=gb:5,down,1             # Short hi-hat hits (faster, lower env)
inst perc  type=noise  env=gb:10,down,1            # Generic percussion/noise channel

# -----------------------------------------------------------------------------
# Patterns
# Patterns are sequences of tokens (notes like C4, rests `.` and identifiers).
# They may include grouping with `(...)` and repetition with `*N`.
# Inline tokens like `inst(name)` or `inst(name,N)` temporarily change the
# instrument for the following notes (temporary override count `N` decrements
# when non-rest notes are played).

# Melodic pattern for the lead channel.
# - Twinkle-style motif arranged into a fixed 16-token pattern (two 8-step phrases).
pat A      = (C5 C5 G5 G5 A5 A5 G5 .) (F5 F5 E5 E5 D5 D5 C5 .)

# Alternative, sparser lead pattern for variation (16 tokens total).
pat A_alt  = (. C5 . C5 . G5 . G5 .) * 2

# Simple bass pattern that follows the root movement of the melody (16 tokens).
pat B      = C3 C3 G2 G2 A2 A2 G2 . C3 C3 G2 G2 A2 A2 G2 .

# Wavetable arpeggio pattern to add harmonic color under the melody (16 tokens).
pat C      = (C4 E4 G4 C5) (C4 E4 G4 C5) (C4 E4 G4 C5) (C4 E4 G4 C5)

# Reduced percussion pattern: fewer explicit hits spread over 16 tokens.
pat P      = . . snare . . hihat . . . snare . . . . . .

# Short melodic fill used between phrases (16 tokens).
pat E      = (C5 E5 G5 C6) * 4

# -----------------------------------------------------------------------------
# New shorthand examples
# You can use `name*4` as a concise shorthand to emit the named instrument
# hit 4 times in a row (equivalent to `hit(name,4)`). This is useful for
# percussion stabs where you want immediate repeated hits without inserting
# explicit note tokens. `inst(name,N)` still acts as a temporary override
# for the next N non-rest notes.
pat P2     = snare . . . snare . . . hihat . . . . . . .

# -----------------------------------------------------------------------------
# Channel routing
# Map logical channels to instruments and patterns. Each `channel N => ...`
# line sets the channel ID (1-4) and a default instrument plus the sequence
# to play. `bpm=` controls tempo for that channel.
# - Channel 1: Pulse 1 lead (primary melody)
# - Channel 2: Pulse 2 lead (harmonic/alternate melody)
# - Channel 3: Wave channel (wavetable arpeggio) transposed down one octave
# - Channel 4: Noise/percussion channel

## Example sequencing: create separate sequences per part and map to channels
# Each channel consumes its own sequence. This keeps parts independent and
# lets you modify/loop them separately in the tracker or live UI.

# Lead sequence (primary melody)
seq lead = A A_alt E A

# Bass sequence (low-end walking bass)
seq bass = B B B B

# Wave sequence (wavetable arpeggios)
seq wave = C C C

# Drums/percussion sequence
seq drums = P P2 P P

## Map channels to their separate sequences.
channel 1 => inst leadA seq lead
channel 2 => inst leadB seq bass:oct(-1)
channel 3 => inst wave1 seq wave:oct(-1)
channel 4 => inst perc  seq drums

# -----------------------------------------------------------------------------
# Playback directive
# The `play` directive starts playback in the web UI player. In the CLI this
# would trigger immediate rendering or playback; in the web UI the UI uses the
# parsed AST to schedule audio.
play

# -----------------------------------------------------------------------------
# Speed examples (commented)
#
# You can set a master BPM at the top of the file and then use `speed` on a
# per-channel basis to play that channel at a multiple of the master tempo.
# These lines are commented out so they won't conflict with the active
# channel mappings above â€” uncomment to try them in the demo.

# # channel mapping using master BPM
# channel 1 => inst leadA seq lead
# # channel 2 plays twice as fast as the master (2x)
# channel 2 => inst leadB seq bass speed=2x
# # channel 3 uses master tempo (wavetable)
# channel 3 => inst wave1 seq wave
# # channel 4 percussion at master tempo
# channel 4 => inst perc  seq drums

